# 1.2 프로그래밍 패러다임


GoF(Gang of Fout, 디자인 패턴을 구체화하고 체계화한 사람들)이 세가지로 분류한 디자인 패턴.

| 생성 패턴 (Creational)   |      구조 패턴 (Structual)      |  행위 패턴 (Behavioral) |
|----------|:-------------:|------:|
| 1.1.1 싱글톤 패턴 |1.1.5 프록시 패턴 |1.1.3 전략 패턴 |
1.1.2 추상 팩토리/팩토리 메서드 패턴
1.1.4 옵저버 패턴
1.1.6 이터레이터 패턴
cf. 템플릿 메서드 패턴


- 생성(Creational) 패턴
  - 객체 생성에 관련된 패턴
  - 객체의 생성과 조합을 캡슐화해 특정 객체가 생성되거나 변경되어도 프로그램 구조에 영향을 크게 받지 않도록 유연성을 제공한다.
- 구조(Structural) 패턴
  - 클래스나 객체를 조합해 더 큰 구조를 만드는 패턴
  - 예를 들어 서로 다른 인터페이스를 지닌 2개의 객체를 묶어 단일 인터페이스를 제공하거나 객체들을 서로 묶어 새로운 기능을 제공하는 패턴이다.
- 행위(Behavioral)
  - 객체나 클래스 사이의 알고리즘이나 책임 분배에 관련된 패턴
  - 한 객체가 혼자 수행할 수 없는 작업을 여러 개의 객체로 어떻게 분배하는지, 또 그렇게 하면서도 객체 사이의 결합도를 최소화하는 것에 중점을 둔다.

출처: https://gmlwjd9405.github.io/2018/07/06/design-pattern.html





## 1.2.1 선언형과 함수형 프로그래밍
> 57 page


함수형 프로그래밍
- 프로그램은 함수로 이루어진 것. 선언형 패러다임의 일종
- 순수 함수들을 블록처럼 쌓아 로직을 구현하고 고차함수를 통해 재사용성을 높인 프로그래밍 패러다임

 
순수 함수(Pure Function)
- Memory or I/O의 관점에서 Side Effect가 없는 함수
- 함수의 실행이 외부에 영향을 끼치지 않는 함수
- 출력이 입력에만 의존
 

고차함수
- 함수가 함수를 값처럼 매개변수로 받아 로직을 생성. 고차함수를 쓰기 위해서 해당 언어가 일급 객체라는 특징을 가져야 함


1급 객체(First-Class Object)
- 변수나 데이터 구조 안에 함수를 담을 수 있다.
- 파라미터로 함수를 전달 할 수 있다.
- 함수가 함수를 반환할 수 있다.
우리가 일반적으로 알고 개발했던 함수들은 함수형 프로그래밍에서 정의하는 순수 함수들과는 다르다.

 





## 1.2.2 객체 지향 프로그래밍
> 59 page

객체 지향 프로그래밍(OOP)

객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식

Class 추가시 다른 것을 수정안해도 되어 쉽지만, 함수를 넣는다면 모든 클래스에 넣어야 해서 어렵다.

(ex. 부모 사각형 - 자식 여러개 사각형 종류일때 새로운 사각형을 넣는건 쉽지만, 사각형의 넓이 구하는 공식을 함수로 만든다면 모두다 만들어야 되므로 수정이 힘들다)

특징
- 추상화 : 복잡한 시스템으로 부터 핵심적인 개념 또는 기능을 간추려내는 것

- 캡슐화 : 객체의 속성과 메서드를 하나로 묶고 일부를 외부에 감추어 은닉

- 상속성 : 상위 클래스의 특성을 하위 클래스가 이어받아 재사용하거나 추가 확장하는 것

- 다형성 : 하나의 메서드나 클래스가 다양한 방법으로 동작

 
> 60 page

오버로딩과 오버라이딩

오버로딩

- 같은 이름을 가진 메서드를 여러개 두는것

- 같은 클래스와 상속 관계에서도 가능

- 메서드 이름만 같게하고 메서드 타입, 매개변수 유형, 개수 등을 다르게 하여 여러개 만들 수 있다.

- 정적바인딩 : 호출한 메서드를 컴파일 시 결정

오버라이딩

- 상위클래스로 부터 상속바든 메서드를 하위 클래스가 재정의

- 재정의 : 함수 껍데기는 같고 내용을 재작성 (static, private, final은 오버라이딩x)

- 상속에서만 가능

- 동적바인딩 : 실행할 메서드를 컴파일시에 결정하지 않고 실행 시 결정. 서브 클래스에서 오버라이딩 된 메서드를 무조건 실행

> 62 page

단일책임원칙(SRP) : 모든 클래스는 각각 하나의 책임만 가져야 하는 원칙

개방-패쇄원칙(OCP) : 코드는 쉽게 확장할 수 있어야 하고 수정할 때는 닫혀 있어야 하는 원칙

리스코프 치한 원칙(LSP) : 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 하는 원칙

인터페이스 분리 원칙(ISP) : 하나의 일반적인 인터페이스보다 구체적인 여러개의 인터페이스를 만들어야 하는 원칙

의존 역전 원칙(DIP) : 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 원칙



## 1.2.3 절차형 프로그래밍
> 63 page

절차형 프로그래밍

로직이 수행되어야 할 연속적인 계산과정

Java로도 절차형 프로그래밍을 할 수 있다.

새로운 함수를 만들 때 다른건 수정 안해도 된다. 그러나, Class를 만들때는 함수들을 모두 수정해야한다.

(ex. 사각형의 넓이를 구할 때 넓이 구하는 메소드에 if-else 문으로 사각형마다의 식을 넣어주면 된다. 새로운 함수를 넣을때는 이 함수를 수정안해도 추가 가능하다. 하지만, 새로운 사각형을 추가한다고 하면 모든 함수에 대해 수정이 이루어져야 한다)


## 1.2.4 패러다임의 혼합






