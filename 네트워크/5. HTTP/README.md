# 2.5 HTTP
> p.114
- 인터넷 상에서 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약

- 클라이언트와 서버를 분리함으로써 각가의 역할에 집중할 수 있다.

- 무상태성(stateless)
```
무상태(Stateless) : 클라이언트와 서버 사이에 상태를 유지하지 않는다. => 서버는 클라이언트의 상태를 보존하지 않는다.
장점: 서버 확장성 높음(스케일 아웃)
단점: 클라이언트가 추가 데이터 전송 (메모리 ↑)
```
- 비연결성(connectionless)
```
서버와 클라이언트의 Connection 연결을 지속하지 않는다.
클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않음
이러한 비연결성 특성 때문에 서버 자원을 매우 효율적으로 사용할 수 있다.
```
- 무상태성 vs 비연결성
```
무상태성은 클라이언트와 서버 간에 상태 정보를 들고있지않아 클라이언트가 상태 정보를 일일히 http에 실어 요청해야되는 것을 말하고, 비연결성은 클라이언트와 서버 간에 네트워크 연결이 끊어져 단절된다고 이해하면 된다.
```
#### HTTP 메서드 5가지
- HTTP 메소드는 클라이언트가 서버에게 사용자 요청의 목적을 알리는 '수단'
- HTTP 메서드는 총 9가지가 있으나 그 중 5가지를 알아본다

|종류|	기능|
| --- | --- | 
|GET|	데이터 조회|
POST|	요청 데이터 처리(보통 데이터 등록 사용)
PUT	|데이터 변경 (해당 데이터가 없으면 생성)
PATCH|	일부 데이터만 변경
DELETE|	데이터 삭제


HTTP 메서드 특성
- 안전성(Safe)
```
- 호출해도 리소스 변경이 일어나지 않는 속성
- 여기서 안전의 기준은 오직 리소스 변경 가능성이며, 외적인 요소는 포함하지 않는다.
- GET을 안전한 메소드라고 볼 수 있다. (POST, PUT, PATCH, DELETE는 리소스를 변경하는 메소드이므로)
```


- 멱등성(Idempotent)
```
- 동일한 요청을 여러 번 보내도 한 번 보내는 것과 같은 것
- 같은 행위를 여러 번 반복하더라도 같은 효과를 받으며, 서버의 상태로 동일하게 남음
- 멱등성은 요청의 결과를 보고 판단
- TimeOut 등으로 클라이언트가 서버로부터 정상 응답을 받지 못 했을 때 같은 요청을 다시 해도 되는지 판단하는 근거

GET : 몇 번을 조회하더라도 같은 결과가 조회된다. ⇒ 회원 정보를 몇번을 조회한다고 정보가 달라지지 않는다. 
PUT : 결과를 대체한다. 따라서 같은 요청을 여러번해도 최종 결과는 같다.
DELETE : 결과를 삭제한다. 같은 요청을 여러번 해도 삭제된 결과는 같다.
POST : 멱등이 아니다. 두 번 호출하면 에러가 발생할수 있다. ⇒ POST로 주문을 두 번 호출하면 결제가 중복될 수 있다.
```
- 캐시 가능 (Cacheable) 
```
- 응답 결과를 캐시해 사용할 수 있는 속성
- GET, POST, PATCH가 캐시 가능하나, Message Body의 캐시 키의 복잡성 문제로 실제로는 GET만 사용
```

#### GET VS POST
- GET
```
조회에 많이 사용
GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분에 url 이 담겨서 전송
url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 됨
이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.
보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)
```

- POST
```
POST 방식의 request 는 HTTP Request Message의 Body 부분에 데이터가 담겨서 전송
때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만하다.)
```
- GET VS POST
```
GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다고 볼 수 있는 것이다. 반면에 POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

부수적인 차이점을 좀 더 살펴보자면 GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.
```


#### PUT VS PATCH
- PUT
```
모든 값들을 UPDATE (보내지 않는 값들은 NULL 이 된다)
요청값이 없으면 새로 생성
멱등성 측면에서 PUT은 계속 똑같으므로 멱등성이 있다
```
- PATCH
```
보낸 값들만 UPDATE
요청값이 없으면 새로 생성 하지 않는다
어떻게 설계하느냐에 따라 멱등성이 있을수도 없을 수도 ( EX. 그냥 이름 변경은 멱등성이 있다. 그러나 +1을 계속 한다면 값이 계속 바뀌므로 멱등성이 없다)
```



전체 흐름 정리

|   | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 |
| --- | --- | --- | --- | --- |
| 해결 | \- | keep-alive 옵션으로 한 번의 tcp 연결 후에 여러 개의 파일을 송수신할 수 있음       | 1\. 헤더압축   2\. 멀티플렉싱   3\. 서버 푸시 | QUIC 계층 위에서 UDP 기반으로 돌아가 초기 연결 시 지연시간이 감소한다. |
| 문제 | 매번 TCP 3-way handshake를 해서 RTT 증가 | 1\. 헤더의 중복: 다양한 기능 지원에 따라 헤더에 많은 메타데이터가 담김. 하지만 매 요청마다 헤더를 중복 전송해서 낭비됨   2\. HOLB: 멀티플렉싱이 안되어 서버가 항상 요청받은 순서대로 응답해야하므로 이전 응답에 문제가 생기면 다음 요청들이 지연됨   3\. 클라이언트 요청이 없으면 서버는 먼저 데이터를 못보냄 | HOLB는 해결되었으나 TCP의 HOLB가 해결안됨. TCP는 순서대로 와야하는데 어느하나 로스되면 전체 연결이 중단됨. | \- |

<br/>

## 2.5.1 HTTP/1.0

## 2.5.2 HTTP/1.1

## 2.5.3 HTTP/2
> 119 page

멀티플렉싱

단일 링크를 통해 여러개의 신호를 동시에 전송할 수 있도록 하는 기술

메시지들을 프레임이라는 단위로 잘라서 전송한다. 각 프레임들은 특정 스트림에 속하는 메세지와 연결된다.  
이 모든 프로세스가 한개의 TCP 커넥션 상에서 발생하므로 (한명의 웨이터가 처리하므로) 여러개의 TCP 커넥션으로 병렬처리했던 HTTP/1.1와 다른 멀티플렉싱이다.

cf. 바이너리 프레이밍: 멀티플렉싱의 핵심으로, 텍스트 형식이었던 HTTP 메시지를 더 작게 쪼개 바이너리 형태로 캡슐화한 것. 각 프레임은 어떤 스트림에 속하는지 정보를 가진 프레임 헤더 기능을 지니고 있다. 이러한 프레임은 목적지에 도착해서 완전한 시퀀스인 메세지로 재조립된다.

[여기](https://freecontent.manning.com/animation-http-1-1-vs-http-2-vs-http-2-with-push/)서 HTTP/1.1과 HTTP/2의 차이를 애니메이션으로 이해할 수 있다.

<br/>

## 2.5.4 HTTPS

HTTP vs HTTPS  
HTTP는 암호화가 되지 않은 텍스트를 전송하므로 제 3자가 정보를 조회할 수 있다.   
HTTPS는 애플리케이션과 전송 계층에 SSL 이라는 보안 계층을 추가하여 네트워크 상에서 제 3자가 정보를 볼 수 없도록 암호화를 지원한다.

> 126 page

SHA-256 알고리즘: 대표적인 해시함수. 블록체인 등에 쓰이며 매우 안전하다.
<br/>

## 2.5.5 HTTP/3

HTTP/2에서 해결되지 않았던 TCP의 HOLB 문제를 UDP를 사용함으로써 해결했다.
cf. TCP의 HOLB 문제는 [여기](https://mugglim.tistory.com/26)를 참고

UDP로 변경됨으로써의 안정성은 QUIC가 가지고 있는 메커니즘을 통해 보장할 수 있다.
아래와 같이 보안 계층인 QUIC 프로토콜이 전송 계층인 TCP가 해주던 일까지 하고 있는 것을 볼 수 있다.

![](https://docs.rackspace.com/blog/quic-a-game-changer/quic-protocol.png)

<br/>
