# 2.5 HTTP
전체 흐름 정리

|   | HTTP/1.0 | HTTP/1.1 | HTTP/2 | HTTP/3 |
| --- | --- | --- | --- | --- |
| 해결 | \- | keep-alive 옵션으로 한 번의 tcp 연결 후에 여러 개의 파일을 송수신할 수 있음       | 1\. 헤더압축   2\. 멀티플렉싱   3\. 서버 푸시 | QUIC 계층 위에서 UDP 기반으로 돌아가 초기 연결 시 지연시간이 감소한다. |
| 문제 | 매번 TCP 3-way handshake를 해서 RTT 증가 | 1\. 헤더의 중복: 다양한 기능 지원에 따라 헤더에 많은 메타데이터가 담김. 하지만 매 요청마다 헤더를 중복 전송해서 낭비됨   2\. HOLB: 멀티플렉싱이 안되어 서버가 항상 요청받은 순서대로 응답해야하므로 이전 응답에 문제가 생기면 다음 요청들이 지연됨   3\. 클라이언트 요청이 없으면 서버는 먼저 데이터를 못보냄 | HOLB는 해결되었으나 TCP의 HOLB가 해결안됨. TCP는 순서대로 와야하는데 어느하나 로스되면 전체 연결이 중단됨. | \- |

<br/>

## 2.5.1 HTTP/1.0

## 2.5.2 HTTP/1.1

## 2.5.3 HTTP/2
> 119 page

멀티플렉싱

단일 링크를 통해 여러개의 신호를 동시에 전송할 수 있도록 하는 기술

메시지들을 프레임이라는 단위로 잘라서 전송한다. 각 프레임들은 특정 스트림에 속하는 메세지와 연결된다.  
이 모든 프로세스가 한개의 TCP 커넥션 상에서 발생하므로 (한명의 웨이터가 처리하므로) 여러개의 TCP 커넥션으로 병렬처리했던 HTTP/1.1와 다른 멀티플렉싱이다.

cf. 바이너리 프레이밍: 멀티플렉싱의 핵심으로, 텍스트 형식이었던 HTTP 메시지를 더 작게 쪼개 바이너리 형태로 캡슐화한 것. 각 프레임은 어떤 스트림에 속하는지 정보를 가진 프레임 헤더 기능을 지니고 있다. 이러한 프레임은 목적지에 도착해서 완전한 시퀀스인 메세지로 재조립된다.

[여기](https://freecontent.manning.com/animation-http-1-1-vs-http-2-vs-http-2-with-push/)서 HTTP/1.1과 HTTP/2의 차이를 애니메이션으로 이해할 수 있다.

<br/>

## 2.5.4 HTTPS

HTTP vs HTTPS  
HTTP는 암호화가 되지 않은 텍스트를 전송하므로 제 3자가 정보를 조회할 수 있다.   
HTTPS는 애플리케이션과 전송 계층에 SSL 이라는 보안 계층을 추가하여 네트워크 상에서 제 3자가 정보를 볼 수 없도록 암호화를 지원한다.

> 126 page

SHA-256 알고리즘: 대표적인 해시함수. 블록체인 등에 쓰이며 매우 안전하다.
<br/>

## 2.5.5 HTTP/3

HTTP/2에서 해결되지 않았던 TCP의 HOLB 문제를 UDP를 사용함으로써 해결했다.
cf. TCP의 HOLB 문제는 [여기](https://mugglim.tistory.com/26)를 참고

UDP로 변경됨으로써의 안정성은 QUIC가 가지고 있는 메커니즘을 통해 보장할 수 있다.
아래와 같이 보안 계층인 QUIC 프로토콜이 전송 계층인 TCP가 해주던 일까지 하고 있는 것을 볼 수 있다.

![](https://docs.rackspace.com/blog/quic-a-game-changer/quic-protocol.png)

<br/>
