
## 3.2.1 메모리 계층

p.142

CPU는 그저 메모리에 올라와 있는 프로그램의 명령어들을 실행함.

 

p.143

3.2.1 메모리 계층
메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있음.

레지스터	전원이 나가면 지워진다.	용량 작음, 속도 빠름












용량 큼, 속도 느림
캐시
주기억장치
전자디스크	전원이 나가도 정보가 저장됨.
자기디스크
광디스크
자기테이프
레지스터: CPU 안에 있는 작은 메모리. 휘발성. 속도 가장 빠름. 기억 용량 가장 적음.
캐시: L1, L2 캐시 지칭. 휘발성. 속도 빠름. 기억 용량 적음. L3 캐시도 있음.
주기억 장치: RAM을 가리킴. 휘발성. 속보 보통. 기억용량 보통
보조기억 장치: HDD, SDD를 일컬음. 비휘발성. 속도 낮음. 기억용량 많음.
L1 Cache: 프로세서와 가장 가까운 캐시. 속도를 위해 I$와 D$로 나뉜다.
Instruction Cache (I$): 메모리의 TEXT 영역 데이터를 다루는 캐시.
Data Cache (D$): TEXT 영역을 제외한 모든 데이터를 다루는 캐시.
L2 Cache: 용량이 큰 캐시. 크기를 위해 L1 캐시처럼 나누지 않는다.
L3 Cache: 멀티 코어 시스템에서 여러 코어가 공유하는 캐시.
ㄴ 출처: https://parksb.github.io/article/29.html

 

램은 하드디스로부터 일정량의 데이터를 복사해서 임시 저장하고 필요할 때마다 CPU에 빠르게 전달.

계층 위로갈수록 빘싸짐. 경제성 때문에 계층을 두어 관리함.

로딩중? - 하드디스크 또는 인터넷에서 데이터를 읽어 RAM으로 전송하는 과정이 아직 끝나지 않음을 의미.

 

p. 144

캐시(cache)

데이터를 미리 복사해 놓는 임시 저장소이자 빠른 장치와 느린 장치엣서 속도 차이에 따른 병목 현ㅅ상을 줄이기 위한 메모리.

데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있음.

속도 차이를 해결하기 위해 계층과 계층 사이에 있는 계층을 캐싱 계층이라고 함.

 

지역성의 원리

캐시 계층을 두는 것 말고 캐시를 직접 설정할 때는 어떻게 해아 하는가?

->자주 사용하는 데이터를 기반으로 설정해야함.

자주 사용하는 데이터에 대한 근거가 되는 것은?

->지역성. 시간 지역성과 공간 지역성으로 나뉨.

 

시간 지역성(temporal locality)

최근 사용한 데이터에 다시 접근하려는 특성.

데이터의 읽기/쓰기를 위해 특정 메모리가 사용됐을 때 가까운 시일 내에 해당 메모리가 다시 사용될 가능성이 높은 것.

밑의 코드에서 데이터는 변수 i이고 최근에 사용했기 대문에 계속 접근해서 +1을 연이어 함.

 

//책 144쪽 코드
let arr = Array.from({length : 10}, () => 0);
console.log(arr)
for(let i = 0; i < 10; i += 1) {
	arr[i] = i;
}
console.log(arr)
 

공간 지역성(spatial locality)

최근 접근한 데이터를 이루고 있는 공간이나 그 가까운 공간에 접근하는 특성

특정 데이터와 가까운 주소가 순서대로 접근되는 경우.

한 메모리 주소에 접근할 때 그 주소뿐만 아니라 해당 블록을 전부 캐시에 가져옴으로써 공간 지역성의 효율을 높임.

위의 코드에서 공간을 나타내는 배열 arr의 각 요소들에 i가 할당되며 해당배열에 연속적으로 접근함.

 

int arr[30000][30000] = {};
for(int i = 0; i < 30000; i++){
	for(int j = 0; j < 3000; j++)
    {
    	(1)arr[i][j] = 1;
        (2)arr[j][i] = 1;
    }
}
(1)의 경우: 메모리에 연속적으로 접근

(2)의 경우: 메모리에 연속적으로 접근하지 못해 시간이 오래 걸림.

 

(시간 지역성, 공간 지역성 설명 및 이중for문 코드

출처: https://literate-t.tistory.com/73 )

 

p. 145 

캐시히트와 캐시미스

캐시히트: 캐시에서 원하는 데이터를 찾음.

캐시미스: 해당 데이터가 캐시에 없다면 주메모리로 가서 데이터를 찾아오는 것.


https://velog.velcdn.com/images/ssongjh55/post/e0d8706c-62fd-458f-af92-2b62182a60e3/image.png
캐시히트를 하게 되면 해당 데이터를 제어장치를 거쳐 가져옴. 위치도 가깝고 CPU 내부 버스를 기반으로 작동하기 때문에 빠름.

캐시미스가 발생되면 메모리에서 가져오게 되는데, 시스템 버스를 기반으로 작동하기 때문에 느림

 

캐시매핑

캐시가 히트되기 위해 매핑하는 방법.

CPU의 레지스터와 주 메모리(RAM) 간에 데이터를 주고받을 때를 기잔으로 설명.

레지스터는 주 메모리에 비해 굉장히 작고 주 메모리는 굉장히 크기 때문에 작은 레지스터가 캐시 계층으로써 역할을 잘 하기 위해 이 매핑을 어떻게 하느냐가 중요.

 

-직접매핑(Directed Mapping)

메모리 주소와 캐시의 순서를 일치시킴.

메모리: 1~100 / 캐시: 1~10 이 있다고 하자.

1~10까지의 메모리는 캐시의 1에, 11~20까지의 메모리는 캐시의 2에 매칭하는 것.

구현이 간단하지만 캐시를 넣다보면 캐시가 비효율적으로 자꾸 교체되어야 하는 일이 생김. -> 적중률이 낮고 성능이 낮은 단순한 방식.

(30~40에 해당하는 값을 자꾸 불러다 사용해야 하는데 저장할 캐시공간은 3 하나 뿐이므로 매번 캐시 교체가 일어남.)

메인 메모리와 캐시를 똑같은 크기로 나누고 순서대로 매핑하는 것.

처리가 빠르지만 충돌발생이 잦음.

 

-연관 매핑(associative mapping)

순서를 일치시키지 않음.

필요한 메모리값을 캐시의 어디든 편하게 저장될 수 있음.

찾는 과정은 복잡하고 느릴 수 있지만 필요한 캐시들 위주로 저장할 수 있기 때문에 적중률은 높다.

충돌이 적지만 모든 블록을 탐색해야 해서 속도가 느림.

 

-집합 연관 매핑(set associative mapping)

연관매핑+직접매핑.

순서는 일치시키지만 집합을 둬서 저장. 블록화되어 있어 검색은 좀더 효율적

예: 메모리가 1~100이 있고 캐시가 1~10이 있다면 캐시 1~5에는 1~50의 데이터를 무작위로 저장하는 것.

직접매핑처럼 저장위치에 대해 큰 제약이 있는 건 아니기 때문에 적중률이 많이 떨어지지 않는다.

ㄴ출처: https://gguljaem.tistory.com/entry/%EC%BA%90%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%9D%98-%EA%B0%9C%EB%85%90%EA%B3%BC-%EB%A7%A4%ED%95%91%EA%B8%B0%EB%B2%95%EC%97%90-%EB%8C%80%ED%95%9C-%EC%84%A4%EB%AA%85

 

웹 브라우저의 캐시

소프트웨어적인 대표적인 캐시: 웹 브라우저의 쿠키, 로컬 스토리지, 세션 스토리지.

보통 사용자의 커스텀한 정보나 인증모듈 관련 사항들을 웹 브라우저에 저장해서 추후 서버에 요청할 때 자신을 나타내는 아이덴티티나 중복 요청 방지를 위해 쓰임.

 

쿠키, 로컬 스토리지, 세션 스토리지 (종류, 동작 원리, 특징) 참고 블로그: https://velog.io/@hs0217/%EC%BF%A0%ED%82%A4-%EB%A1%9C%EC%BB%AC-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80-%EC%84%B8%EC%85%98-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80

 

쿠키

만료 기한이 있는 키-값 저장소.

4kb까지 데이터를 저장할 수 있고 만료기한을 정할 수 있음.

만료 기간이 있는 클라이언트 단에 저장하는 작은 텍스트 파일.

요청과 응답만이 존재했던 HTTP 웹세계에 이전에 서버와 클라이언트가 주고 받은 내역을 기억하고 불러올 수 있는 혁신적인 역할 수행.

session cookie, persistent cookie, secure cookie, third party cookie

**일시적으로 필요한 가벼운 데이터 저장이 필요할 때 사용: 다시보지 않음 쿠키 팝업창, 로그인 자동 완성

 

웹 스토리지

웹 브라우저를닫아도 유지되고 도메인 단위로 저장, 생성됨.

클라이언트에 데이터를 저장할 수 있도록 HTML5부터 나온 새로운 방식의 데이터 저장소.

key와 value 쌍의 형태로 데이터 저장.

로컬 스토리지와 세션 스토리지가 있음.

 

로컬스토리지

만료기한이 없는 키-값 저장소.

10MB 까지 저장 가능.

웹 브라우저를 닫아도 유지되고 도메인 단위로 저장 ,생성됨.

HTML5를 지원하지 않는 브라우저에서는 사용할 수 없고 클라이언트에서만 수정 가능.

**지속적으로 필요한 저장이 필요할 때: 자동 로그인

 

세션 스토리지

만료 기한이 없는 키-값 저장소.

탭 단위로 세션 스토리지를 생성하며, 탭을 닫을 때 해당 데이터 삭제됨.

5MB까지 저장 가능하고 HTML5를 지원하지 않는 브라우저에서는 사용할 수 없으며 클라이언트에서만 수정 가능.

**일시적으로 필요한 데이터 저장이 필요할 때: 일회성 로그인, 입력 폼 저장, 비로그인 장바구니

 

데이터베이스의 캐싱 계층

데이터 베이스 시스템을 구축할 때도 메인 데이터베이스 위에 레디스(redis) 데이터 베이스 계층을 '캐싱 계층'으로 둬서 성능을 향상시키기도 함.

 

Redis(Remote Dictionary Server)

메모리 기반의 키-값 구조 데이터 관리 시스템

비관계형 데이터베이스

자바 자료구조와 유사한 영속적인 자료구조 제공(키는 객체 식별 역할)

크게 String, Set, Sorted, Set, Hash, List 데이터 형식 지원 

읽기 성능 증대를 위한 서버 측 복제 지원

쓰기 성능 증대를 위한 클라이언트 측 Sharding 지원

(출처: https://velog.io/@ayoung0073/database-redis )
